import{w as W}from"./index.06520791.js";import{V as en}from"./index.4da1f6d7.js";import{g as rn}from"./nostr.5a67cad7.js";import{r as it}from"./___vite-browser-external_commonjs-proxy.95422cd8.js";var rt,Et;function on(){return Et||(Et=1,rt=function(){throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")}),rt}const sn=typeof WebSocket<"u"?WebSocket:on();N.prototype.wait_connected=async function(n){let i=1e3;for(;;)if(this.ws.readyState!==1)await It(i),i*=1.5;else return};function N(s,n={}){if(!(this instanceof N))return new N(s,n);this.url=s,this.opts=n,n.reconnect==null&&(n.reconnect=!0);const i=this;return i.onfn={},Tt(i).catch(u=>{i.onfn.error&&i.onfn.error(u)}),this}function Tt(s){return new Promise((n,i)=>{const u=s.ws=new sn(s.url);let m=!1;u.onmessage=d=>{cn(s,d),s.onfn.message&&s.onfn.message(d)},u.onclose=d=>{if(s.onfn.close&&s.onfn.close(d),s.reconnecting)return i(new Error("close during reconnect"));!s.manualClose&&s.opts.reconnect&&St(s)},u.onerror=d=>{if(s.onfn.error&&s.onfn.error(d),s.reconnecting)return i(new Error("error during reconnect"));s.opts.reconnect&&St(s)},u.onopen=d=>{s.onfn.open&&s.onfn.open(d),!m&&(m=!0,n(s))}})}function It(s){return new Promise(n=>setTimeout(n,s))}async function St(s){let n=100;try{s.reconnecting=!0,await Tt(s),s.reconnecting=!1}catch{await It(n),n*=1.5}}N.prototype.on=function(n,i){return this.onfn[n]=i,this};N.prototype.close=function(){this.ws&&(this.manualClose=!0,this.ws.close())};N.prototype.subscribe=function(n,i){Array.isArray(i)?this.send(["REQ",n,...i]):this.send(["REQ",n,i])};N.prototype.unsubscribe=function(n){this.send(["CLOSE",n])};N.prototype.send=async function(n){await this.wait_connected(),this.ws.send(JSON.stringify(n))};function cn(s,n){let i;try{i=JSON.parse(n.data)}catch(u){console.error("handle_nostr_message",u);return}if(i.length>=2)switch(i[0]){case"EVENT":return i.length<3?void 0:s.onfn.event&&s.onfn.event(i[1],i[2]);case"EOSE":return s.onfn.eose&&s.onfn.eose(i[1]);case"NOTICE":return s.onfn.notice&&s.onfn.notice(...i.slice(1));case"OK":return s.onfn.ok&&s.onfn.ok(...i.slice(1))}}var $t=N;const M=$t;function B(s,n){if(!(this instanceof B))return new B(s,n);this.onfn={},this.relays=[],this.opts=n;for(const i of s)this.add(i);return this}B.prototype.close=function(){for(const n of this.relays)n.close()};B.prototype.on=function(n,i){for(const u of this.relays)this.onfn[n]=i,u.onfn[n]=i.bind(null,u);return this};B.prototype.has=function(n){for(const i of this.relays)if(i.url===n)return!0;return!1};B.prototype.send=function(n,i){const u=i?this.find_relays(i):this.relays;for(const m of u)m.send(n)};B.prototype.setupHandlers=function(){const n=Object.keys(this.onfn);for(const i of n)for(const u of this.relays)u.onfn[i]=this.onfn[i].bind(null,u)};B.prototype.remove=function(n){let i=0;for(const u of this.relays){if(u.url===n)return u.ws&&u.ws.close(),this.relays=this.replays.splice(i,1),!0;i+=1}return!1};B.prototype.subscribe=function(n,i,u){const m=u?this.find_relays(u):this.relays;for(const d of m)d.subscribe(n,i)};B.prototype.unsubscribe=function(n,i){const u=i?this.find_relays(i):this.relays;for(const m of u)m.unsubscribe(n)};B.prototype.add=function(n){if(n instanceof M)return this.has(n.url)?!1:(this.relays.push(n),this.setupHandlers(),!0);if(this.has(n))return!1;const i=M(n,this.opts);return this.relays.push(i),this.setupHandlers(),!0};B.prototype.find_relays=function(n){if(n instanceof M)return[n];if(n.length===0)return[];if(!n[0])throw new Error("what!?");return n[0]instanceof M?n:this.relays.reduce((i,u)=>(n.some(m=>u.url===m)&&i.push(u),i),[])};var an=B;function un(s){throw new Error('Could not dynamically require "'+s+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var Y={},fn={get exports(){return Y},set exports(s){Y=s}};(function(s,n){/*! noble-secp256k1 - MIT License (c) Paul Miller (paulmillr.com) */Object.defineProperty(n,"__esModule",{value:!0}),n.utils=n.schnorr=n.verify=n.signSync=n.sign=n.getSharedSecret=n.recoverPublicKey=n.getPublicKey=n.SignResult=n.Signature=n.Point=n.CURVE=void 0;const i={a:0n,b:7n,P:2n**256n-2n**32n-977n,n:2n**256n-432420386565659656852420866394968145599n,h:1n,Gx:55066263022277343669578718895168534326250603453777594175500187360389116729240n,Gy:32670510020758816978083085130507043184471273380659243275938904335757337482424n,beta:0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501een};n.CURVE=i;function u(r){const{a:t,b:e}=i;return h(r**3n+t*r+e)}const m=i.a===0n;class d{constructor(t,e,o){this.x=t,this.y=e,this.z=o}static fromAffine(t){if(!(t instanceof g))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new d(t.x,t.y,1n)}static toAffineBatch(t){const e=Kt(t.map(o=>o.z));return t.map((o,c)=>o.toAffine(e[c]))}static normalizeZ(t){return d.toAffineBatch(t).map(d.fromAffine)}equals(t){const e=this,o=t,c=h(e.z*e.z),a=h(e.z*c),f=h(o.z*o.z),l=h(o.z*f);return h(e.x*f)===h(c*o.x)&&h(e.y*l)===h(a*o.y)}negate(){return new d(this.x,h(-this.y),this.z)}double(){const t=this.x,e=this.y,o=this.z,c=h(t**2n),a=h(e**2n),f=h(a**2n),l=h(2n*(h(h((t+a)**2n))-c-f)),y=h(3n*c),p=h(y**2n),w=h(p-2n*l),b=h(y*(l-w)-8n*f),E=h(2n*e*o);return new d(w,b,E)}add(t){if(!(t instanceof d))throw new TypeError("JacobianPoint#add: expected JacobianPoint");const e=this.x,o=this.y,c=this.z,a=t.x,f=t.y,l=t.z;if(a===0n||f===0n)return this;if(e===0n||o===0n)return t;const y=h(c**2n),p=h(l**2n),w=h(e*p),b=h(a*y),E=h(o*l*p),S=h(h(f*c)*y),x=h(b-w),U=h(S-E);if(x===0n)return U===0n?this.double():d.ZERO;const D=h(x**2n),et=h(x*D),bt=h(w*D),mt=h(U**2n-et-2n*bt),tn=h(U*(bt-mt)-E*et),nn=h(c*l*x);return new d(mt,tn,nn)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){if(!at(t))throw new TypeError("Point#multiply: expected valid scalar");let e=h(BigInt(t),i.n);if(!m){let w=d.ZERO,b=this;for(;e>0n;)e&1n&&(w=w.add(b)),b=b.double(),e>>=1n;return w}let[o,c,a,f]=ft(e),l=d.ZERO,y=d.ZERO,p=this;for(;c>0n||f>0n;)c&1n&&(l=l.add(p)),f&1n&&(y=y.add(p)),p=p.double(),c>>=1n,f>>=1n;return o&&(l=l.negate()),a&&(y=y.negate()),y=new d(h(y.x*i.beta),y.y,y.z),l.add(y)}precomputeWindow(t){const e=m?128/t+1:256/t+1;let o=[],c=this,a=c;for(let f=0;f<e;f++){a=c,o.push(a);for(let l=1;l<2**(t-1);l++)a=a.add(c),o.push(a);c=a.double()}return o}wNAF(t,e){!e&&this.equals(d.BASE)&&(e=g.BASE);const o=e&&e._WINDOW_SIZE||1;if(256%o)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let c=e&&v.get(e);c||(c=this.precomputeWindow(o),e&&o!==1&&(c=d.normalizeZ(c),v.set(e,c)));let a=d.ZERO,f=d.ZERO;const l=m?128/o+1:256/o+1,y=2**(o-1),p=BigInt(2**o-1),w=2**o,b=BigInt(o);for(let E=0;E<l;E++){const S=E*y;let x=Number(t&p);if(t>>=b,x>y&&(x-=w,t+=1n),x===0)f=f.add(E%2?c[S].negate():c[S]);else{const U=c[S+Math.abs(x)-1];a=a.add(x<0?U.negate():U)}}return[a,f]}multiply(t,e){if(!at(t))throw new TypeError("Point#multiply: expected valid scalar");let o=h(BigInt(t),i.n),c,a;if(m){const[f,l,y,p]=ft(o);let w,b,E,S;[w,E]=this.wNAF(l,e),[b,S]=this.wNAF(p,e),f&&(w=w.negate()),y&&(b=b.negate()),b=new d(h(b.x*i.beta),b.y,b.z),[c,a]=[w.add(b),E.add(S)]}else[c,a]=this.wNAF(o,e);return d.normalizeZ([c,a])[0]}toAffine(t=X(this.z)){const e=t**2n,o=h(this.x*e),c=h(this.y*e*t);return new g(o,c)}}d.BASE=new d(i.Gx,i.Gy,1n),d.ZERO=new d(0n,1n,0n);const v=new WeakMap;class g{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,v.delete(this)}static fromCompressedHex(t){const e=t.length===32,o=k(e?t:t.slice(1)),c=u(o);let a=Zt(c);const f=(a&1n)===1n;e?f&&(a=h(-a)):(t[0]&1)===1!==f&&(a=h(-a));const l=new g(o,a);return l.assertValidity(),l}static fromUncompressedHex(t){const e=k(t.slice(1,33)),o=k(t.slice(33)),c=new g(e,o);return c.assertValidity(),c}static fromHex(t){const e=F(t),o=e[0];if(e.length===32||e.length===33&&(o===2||o===3))return this.fromCompressedHex(e);if(e.length===65&&o===4)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${e.length}`)}static fromPrivateKey(t){return g.BASE.multiply(Z(t))}static fromSignature(t,e,o){let c=t instanceof Uint8Array?k(t):C(t);const a=ht(e),{r:f,s:l}=a;if(o!==0&&o!==1)throw new Error("Cannot recover signature: invalid yParity bit");const y=2+(o&1),p=g.fromHex(`0${y}${T(f)}`),w=d.fromAffine(p).multiplyUnsafe(l),b=d.BASE.multiply(c),E=X(f,i.n),x=w.subtract(b).multiplyUnsafe(E).toAffine();return x.assertValidity(),x}toRawBytes(t=!1){return V(this.toHex(t))}toHex(t=!1){const e=T(this.x);return t?`${this.y&1n?"03":"02"}${e}`:`04${e}${T(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{P:e}=i,{x:o,y:c}=this;if(o===0n||c===0n||o>=e||c>=e)throw new Error(t);const a=h(c*c),f=u(o);if((a-f)%e!==0n)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new g(this.x,h(-this.y))}double(){return d.fromAffine(this).double().toAffine()}add(t){return d.fromAffine(this).add(d.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return d.fromAffine(this).multiply(t,this).toAffine()}}n.Point=g,g.BASE=new g(i.Gx,i.Gy),g.ZERO=new g(0n,0n);function O(r){return Number.parseInt(r[0],16)>=8?"00"+r:r}class H{constructor(t,e){this.r=t,this.s=e}static fromCompact(t){if(typeof t!="string"&&!(t instanceof Uint8Array))throw new TypeError("Signature.fromCompact: Expected string or Uint8Array");const e=t instanceof Uint8Array?$(t):t;if(e.length!==128)throw new Error("Signature.fromCompact: Expected 64-byte hex");const o=new H(C(e.slice(0,64)),C(e.slice(64,128)));return o.assertValidity(),o}static fromDER(t){const e="Signature.fromDER";if(typeof t!="string"&&!(t instanceof Uint8Array))throw new TypeError(`${e}: Expected string or Uint8Array`);const o=t instanceof Uint8Array?$(t):t,c=G(o.slice(2,4));if(o.slice(0,2)!=="30"||c!==o.length-4||o.slice(4,6)!=="02")throw new Error(`${e}: Invalid signature ${o}`);const a=G(o.slice(6,8)),f=8+a,l=o.slice(8,f);if(l.startsWith("00")&&G(l.slice(2,4))<=127)throw new Error(`${e}: Invalid r with trailing length`);const y=C(l);if(o.slice(f,f+2)!=="02")throw new Error(`${e}: Invalid r-s separator`);const w=G(o.slice(f+2,f+4)),b=c-w-a-10;if(b>0||b===-4)throw new Error(`${e}: Invalid total length`);if(w>c-a-4)throw new Error(`${e}: Invalid s`);const E=f+4,S=o.slice(E,E+w);if(S.startsWith("00")&&G(S.slice(2,4))<=127)throw new Error(`${e}: Invalid s with trailing length`);const x=C(S),U=new H(y,x);return U.assertValidity(),U}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!_(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!_(e))throw new Error("Invalid Signature: s must be 0 < s < n")}toDERRawBytes(t=!1){return V(this.toDERHex(t))}toDERHex(t=!1){const e=O(Q(this.s));if(t)return e;const o=O(Q(this.r)),c=Q(o.length/2),a=Q(e.length/2);return`30${Q(o.length/2+e.length/2+4)}02${c}${o}02${a}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return V(this.toCompactHex())}toCompactHex(){return T(this.r)+T(this.s)}}n.Signature=H,n.SignResult=H;function I(...r){if(r.length===1)return r[0];const t=r.reduce((o,c)=>o+c.length,0),e=new Uint8Array(t);for(let o=0,c=0;o<r.length;o++){const a=r[o];e.set(a,c),c+=a.length}return e}function $(r){let t="";for(let e=0;e<r.length;e++)t+=r[e].toString(16).padStart(2,"0");return t}function T(r){return r.toString(16).padStart(64,"0")}function z(r){return V(T(r))}function Q(r){const t=r.toString(16);return t.length&1?`0${t}`:t}function C(r){if(typeof r!="string")throw new TypeError("hexToNumber: expected string, got "+typeof r);return BigInt(`0x${r}`)}function V(r){if(typeof r!="string")throw new TypeError("hexToBytes: expected string, got "+typeof r);if(r.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const t=new Uint8Array(r.length/2);for(let e=0;e<t.length;e++){const o=e*2;t[e]=Number.parseInt(r.slice(o,o+2),16)}return t}function F(r){return r instanceof Uint8Array?r:V(r)}function k(r){return C($(r))}function G(r){return Number.parseInt(r,16)*2}function at(r){return!!(typeof r=="bigint"&&r>0n||typeof r=="number"&&r>0&&Number.isSafeInteger(r))}function h(r,t=i.P){const e=r%t;return e>=0?e:t+e}function P(r,t){const{P:e}=i;let o=r;for(;t-- >0n;)o*=o,o%=e;return o}function Zt(r){const{P:t}=i,e=r*r*r%t,o=e*e*r%t,c=P(o,3n)*o%t,a=P(c,3n)*o%t,f=P(a,2n)*e%t,l=P(f,11n)*f%t,y=P(l,22n)*l%t,p=P(y,44n)*y%t,w=P(p,88n)*p%t,b=P(w,44n)*y%t,E=P(b,3n)*o%t,S=P(E,23n)*l%t,x=P(S,6n)*e%t;return P(x,2n)}function X(r,t=i.P){if(r===0n||t<=0n)throw new Error(`invert: expected positive integers, got n=${r} mod=${t}`);let e=h(r,t),o=t,[c,a,f,l]=[0n,1n,1n,0n];for(;e!==0n;){const p=o/e,w=o%e,b=c-f*p,E=a-l*p;[o,e]=[e,w],[c,a]=[f,l],[f,l]=[b,E]}if(o!==1n)throw new Error("invert: does not exist");return h(c,t)}function Kt(r,t=i.P){const e=r.length,o=new Array(e);let c=1n;for(let a=0;a<e;a++)r[a]!==0n&&(o[a]=c,c=h(c*r[a],t));c=X(c,t);for(let a=e-1;a>=0;a--){if(r[a]===0n)continue;const f=h(c*r[a],t);r[a]=h(c*o[a],t),c=f}return r}const ut=(r,t)=>(r+t/2n)/t,j=2n**128n;function ft(r){const{n:t}=i,e=0x3086d221a7d46bcde86c90e49284eb15n,o=-0xe4437ed6010e88286f547fa90abfe4c3n,c=0x114ca50f7a8e2f3f657c1108d9d44cfd8n,a=e,f=ut(a*r,t),l=ut(-o*r,t);let y=h(r-f*e-l*c,t),p=h(-f*o-l*a,t);const w=y>j,b=p>j;if(w&&(y=t-y),b&&(p=t-p),y>j||p>j)throw new Error("splitScalarEndo: Endomorphism failed");return[w,y,b,p]}function Wt(r){typeof r!="string"&&(r=$(r));let t=C(r||"0");const o=r.length/2*8-256;return o>0&&(t=t>>BigInt(o)),t>=i.n&&(t-=i.n),t}function lt(r,t){if(r==null)throw new Error(`sign: expected valid msgHash, not "${r}"`);const e=typeof r=="string"?C(r):k(r),o=z(e),c=k(o),a=z(t);let f=new Uint8Array(32).fill(1),l=new Uint8Array(32).fill(0);const y=Uint8Array.from([0]),p=Uint8Array.from([1]);return[o,c,a,f,l,y,p]}async function Qt(r,t){const e=Z(t);let[o,c,a,f,l,y,p]=lt(r,e);const w=n.utils.hmacSha256;l=await w(l,f,y,a,o),f=await w(l,f),l=await w(l,f,p,a,o),f=await w(l,f);for(let b=0;b<1e3;b++){f=await w(l,f);let E=dt(f,c,e);if(E)return E;l=await w(l,f,y),f=await w(l,f)}throw new TypeError("secp256k1: Tried 1,000 k values for sign(), all were invalid")}function Gt(r,t){const e=Z(t);let[o,c,a,f,l,y,p]=lt(r,e);const w=n.utils.hmacSha256Sync;if(!w)throw new Error("utils.hmacSha256Sync is undefined, you need to set it");if(l=w(l,f,y,a,o),l instanceof Promise)throw new Error("To use sync sign(), ensure utils.hmacSha256 is sync");f=w(l,f),l=w(l,f,p,a,o),f=w(l,f);for(let b=0;b<1e3;b++){f=w(l,f);let E=dt(f,c,e);if(E)return E;l=w(l,f,y),f=w(l,f)}throw new TypeError("secp256k1: Tried 1,000 k values for sign(), all were invalid")}function _(r){return 0<r&&r<i.n}function dt(r,t,e){const o=k(r);if(!_(o))return;const c=i.n,a=g.BASE.multiply(o),f=h(a.x,c),l=h(X(o,c)*(t+f*e),c);if(!(f===0n||l===0n))return[a,f,l]}function Z(r){let t;if(typeof r=="bigint")t=r;else if(typeof r=="number"&&Number.isSafeInteger(r)&&r>0)t=BigInt(r);else if(typeof r=="string"){if(r.length!==64)throw new Error("Expected 32 bytes of private key");t=C(r)}else if(r instanceof Uint8Array){if(r.length!==32)throw new Error("Expected 32 bytes of private key");t=k(r)}else throw new TypeError("Expected valid private key");if(!_(t))throw new Error("Expected private key: 0 < key < n");return t}function J(r){return r instanceof g?(r.assertValidity(),r):g.fromHex(r)}function ht(r){return r instanceof H?(r.assertValidity(),r):H.fromDER(r)}function Xt(r,t=!1){const e=g.fromPrivateKey(r);return typeof r=="string"?e.toHex(t):e.toRawBytes(t)}n.getPublicKey=Xt;function _t(r,t,e){const o=g.fromSignature(r,t,e);return typeof r=="string"?o.toHex():o.toRawBytes()}n.recoverPublicKey=_t;function yt(r){const t=r instanceof Uint8Array,e=typeof r=="string",o=(t||e)&&r.length;return t?o===33||o===65:e?o===66||o===130:r instanceof g}function Ft(r,t,e=!1){if(yt(r))throw new TypeError("getSharedSecret: first arg must be private key");if(!yt(t))throw new TypeError("getSharedSecret: second arg must be public key");const o=J(t);o.assertValidity();const c=o.multiply(Z(r));return typeof r=="string"?c.toHex(e):c.toRawBytes(e)}n.getSharedSecret=Ft;function wt(r,t,e=!1){const[o,c,a]=r;let{canonical:f,der:l,recovered:y}=t,p=(o.x===c?0:2)|Number(o.y&1n),w=a;const b=i.n>>1n;a>b&&f&&(w=i.n-a,p^=1);const E=new H(c,w);E.assertValidity();const S=l===!1?E.toCompactHex():E.toDERHex(),x=e?S:V(S);return y?[x,p]:x}async function jt(r,t,e={}){return wt(await Qt(r,t),e,typeof r=="string")}n.sign=jt;function Lt(r,t,e={}){return wt(Gt(r,t),e,typeof r=="string")}n.signSync=Lt;function Mt(r,t,e){const{n:o}=i;let c;try{c=ht(r)}catch{return!1}const{r:a,s:f}=c,l=Wt(t);if(l===0n)return!1;const y=d.fromAffine(J(e)),p=X(f,o),w=h(l*p,o),b=h(a*p,o),E=d.BASE.multiply(w),S=y.multiplyUnsafe(b),x=E.add(S).toAffine();return h(x.x,o)===a}n.verify=Mt;async function tt(r,...t){const e=new Uint8Array(r.split("").map(a=>a.charCodeAt(0))),o=await n.utils.sha256(e),c=await n.utils.sha256(I(o,o,...t));return k(c)}async function pt(r,t,e){const o=z(r),c=await tt("BIP0340/challenge",o,t.toRawX(),e);return h(c,i.n)}function nt(r){return h(r.y,2n)===0n}class K{constructor(t,e){if(this.r=t,this.s=e,t<=0n||e<=0n||t>=i.P||e>=i.n)throw new Error("Invalid signature")}static fromHex(t){const e=F(t);if(e.length!==64)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);const o=k(e.slice(0,32)),c=k(e.slice(32));return new K(o,c)}toHex(){return T(this.r)+T(this.s)}toRawBytes(){return V(this.toHex())}}function Yt(r){const t=g.fromPrivateKey(r);return typeof r=="string"?t.toHexX():t.toRawX()}async function Jt(r,t,e=n.utils.randomBytes()){if(r==null)throw new TypeError(`sign: Expected valid message, not "${r}"`);t||(t=0n);const{n:o}=i,c=F(r),a=Z(t),f=F(e);if(f.length!==32)throw new TypeError("sign: Expected 32 bytes of aux randomness");const l=g.fromPrivateKey(a),y=nt(l)?a:o-a,p=await tt("BIP0340/aux",f),w=y^p,b=await tt("BIP0340/nonce",z(w),l.toRawX(),c),E=h(b,o);if(E===0n)throw new Error("sign: Creation of signature failed. k is zero");const S=g.fromPrivateKey(E),x=nt(S)?E:o-E,U=await pt(S.x,l,c),D=new K(S.x,h(x+U*y,o));if(!await gt(D.toRawBytes(),c,l.toRawX()))throw new Error("sign: Invalid signature produced");return typeof r=="string"?D.toHex():D.toRawBytes()}async function gt(r,t,e){const o=r instanceof K?r:K.fromHex(r),c=typeof t=="string"?V(t):t,a=J(e),f=await pt(o.r,a,c),l=g.fromPrivateKey(o.s),y=a.multiply(f),p=l.subtract(y);return!(p.equals(g.BASE)||!nt(p)||p.x!==o.r)}n.schnorr={Signature:K,getPublicKey:Yt,sign:Jt,verify:gt},g.BASE._setWindowSize(8);const A=(()=>{const r=typeof self=="object"&&"crypto"in self?self.crypto:void 0;return{node:typeof un=="function"&&!r?it:void 0,web:r}})();n.utils={isValidPrivateKey(r){try{return Z(r),!0}catch{return!1}},randomBytes:(r=32)=>{if(A.web)return A.web.getRandomValues(new Uint8Array(r));if(A.node){const{randomBytes:t}=A.node;return new Uint8Array(t(r).buffer)}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>{let r=8;for(;r--;){const t=n.utils.randomBytes(32),e=k(t);if(_(e)&&e!==1n)return t}throw new Error("Valid private key was not found in 8 iterations. PRNG is broken")},sha256:async r=>{if(A.web){const t=await A.web.subtle.digest("SHA-256",r.buffer);return new Uint8Array(t)}else if(A.node){const{createHash:t}=A.node;return Uint8Array.from(t("sha256").update(r).digest())}else throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(r,...t)=>{if(A.web){const e=await A.web.subtle.importKey("raw",r,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),o=I(...t),c=await A.web.subtle.sign("HMAC",e,o);return new Uint8Array(c)}else if(A.node){const{createHmac:e}=A.node,o=e("sha256",r);for(let c of t)o.update(c);return Uint8Array.from(o.digest())}else throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,precompute(r=8,t=g.BASE){const e=t===g.BASE?t:new g(t.x,t.y);return e._setWindowSize(r),e.multiply(3n),e}}})(fn,Y);const ln=$t,dn=an,q=Y,st=it;async function ct(s,n){return await q.schnorr.sign(n,s)}async function hn(s){return await q.schnorr.verify(s.sig,s.id,s.pubkey)}function yn(s){if(typeof TextEncoder<"u"&&TextEncoder)return new TextEncoder().encode(s);{const n=it;return new n.TextEncoder("utf-8").encode(s)}}async function Ct(s){const n=Nt(s),i=q.utils.sha256,u=yn(n);return Dt(await i(u))}function Nt(s){const{pubkey:n,created_at:i,kind:u,tags:m,content:d}=s;return JSON.stringify([0,n,i,u,m,d])}function Ot(s,n){return`nostr:delegation:${s}:${n}`}async function zt(s,n){const i=Dt(await q.utils.sha256(n));return await ct(s,i)}async function wn(s,n,i){const u=qt(s),m=Ot(n,i),d=await zt(s,m);return{pubkey:u,publisherPubkey:n,conditions:i,token:d}}function Vt(s){const{pubkey:n,conditions:i,token:u}=s;return["delegation",n,i,u]}function pn(s,n){for(const i of s)if(i.length>=4&&i[0]==="delegation"){i[1]=n.pubkey,i[2]=n.conditions,i[3]=n.token;return}s.push(Vt(n))}async function gn(s,n,i){let u=n.tags||[];return pn(u,i),n.tags=u,n.pubkey=i.publisherPubkey,n.id=await Ct(n),n.sig=await ct(s,n.id),n}function xt(s){if(s<10)return String.fromCharCode(48+s);if(s<16)return String.fromCharCode(97+s-10)}function Dt(s){let n="";for(let i=0;i<s.length;i++){const u=s[i];n+=xt(u>>4),n+=xt(u&15)}return n}function bn(s){if(typeof Buffer<"u"&&Buffer)return Buffer.from(s,"base64");if(typeof atob<"u"&&atob)return atob(s);throw new Error("no base64 implementation")}function mn(s,n,i){const m=q.getSharedSecret(s,"02"+n).substr(2,64),d=st.randomBytes(16),v=st.createCipheriv("aes-256-cbc",Buffer.from(m,"hex"),d);let g=v.update(i,"utf8","base64");return g+=v.final("base64"),g+"?iv="+d.toString("base64")}function En(s,n){let[i,u]=n.content.split("?");if(!u||!i)return;u=u.slice(3),u=bn(u);const d=q.getSharedSecret(s,"02"+n.pubkey).substr(2,64),v=st.createDecipheriv("aes-256-cbc",Buffer.from(d,"hex"),u);let g=v.update(i,"base64","utf8");return g+=v.final("utf8"),g}function qt(s){return q.schnorr.getPublicKey(s)}var vt={Relay:ln,RelayPool:dn,signId:ct,verifyEvent:hn,calculateId:Ct,getPublicKey:qt,decryptDm:En,encryptDm:mn,delegationCommitment:Ot,createDelegationTag:Vt,createDelegationEvent:gn,createDelegation:wn,signDelegationToken:zt,eventCommitment:Nt};let L;const Sn=new Uint8Array(16);function xn(){if(!L&&(L=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!L))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return L(Sn)}const R=[];for(let s=0;s<256;++s)R.push((s+256).toString(16).slice(1));function vn(s,n=0){return(R[s[n+0]]+R[s[n+1]]+R[s[n+2]]+R[s[n+3]]+"-"+R[s[n+4]]+R[s[n+5]]+"-"+R[s[n+6]]+R[s[n+7]]+"-"+R[s[n+8]]+R[s[n+9]]+"-"+R[s[n+10]]+R[s[n+11]]+R[s[n+12]]+R[s[n+13]]+R[s[n+14]]+R[s[n+15]]).toLowerCase()}const Rn=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),Rt={randomUUID:Rn};function At(s,n,i){if(Rt.randomUUID&&!n&&!s)return Rt.randomUUID();s=s||{};const u=s.random||(s.rng||xn)();if(u[6]=u[6]&15|64,u[8]=u[8]&63|128,n){i=i||0;for(let m=0;m<16;++m)n[i+m]=u[m];return n}return vn(u)}const An={connecting:"connecting",connected:"connected",disconnected:"disconnected",error:"error"};class Bn{constructor(){this.pool=new vt.RelayPool([]),this.relays=[],this.relayStatus=An.disconnected,this.subscriptionQueue=[]}async add(n){const i=new vt.Relay(n);this.pool.add(i),this.pool.on("open",u=>{this.relays.push(u),Ht.update(m=>(m[u.url]=0,m)),console.log(`Connected to relay ${u.url}, will request ${this.subscriptionQueue.length} subscriptions`),this.subscriptionQueue.forEach(m=>{u.subscribe(At(),m)})}),this.pool.on("event",async(u,m,d)=>await this.processEvent(d,u))}async subscribe(n){this.subscriptionQueue.find(i=>JSON.stringify(i)===JSON.stringify(n))||(console.log("queueing query",JSON.stringify(n)),this.subscriptionQueue.push(n)),this.pool.subscribe(At(),n)}async processEvent(n,i){Ht.update(u=>(u[i.url]=(u[i.url]||0)+1,u));try{n.content=JSON.parse(n.content)}catch{}n.kind===2?console.log(`got post ${n.id}`):n.kind===120?Pt.update(u=>(u.find(m=>m.id===n.id)||(u.unshift(n),this.reqProfile(n.pubkey)),u)):n.kind===0&&(console.log(`got profile ${n.pubkey}`),Ut.update(u=>(u[n.pubkey]={...u[n.pubkey],...n.content},console.log(`there are profiles: ${Object.values(u).length}`),u))),kt.update(u=>(u[n.id]=n,u));for(let u of n.tags){const[m,d]=u;m==="e"&&kt.update(v=>(v.responses[d]=v.responses[d]||[],v.responses[d].includes(n.id)||v.responses[d].push(n.id),v.responses[d].sort((g,O)=>v[g].created_at-v[O].created_at).reverse(),v))}this.subscribe({"#e":[n.id]})}reqEvent(n){console.log(`requesting event ${n}`),Pt[n]||this.subscribe({ids:[n]},{"#e":[n]})}reqProfile(n){Ut[n]||this.subscribe({kinds:[0],authors:[n]})}emptyProfile(n){return{pubkey:n,display_name:n,picture:`https://robohash.org/${n}.png?set=set4`}}async fetchOwnProfile(){try{const n=await window.nostr.getPublicKey();return this.reqProfile(n),this.subscribe({kinds:[2],authors:[n]}),n}catch(n){throw console.log(n),n}}async signAndPublishEvent(n){console.log("signing and publishing event",n),n.id=rn(n);const i=await window.nostr.signEvent(n);return console.log(this.relays),await this.pool.send(["EVENT",i],this.relays),{publishEvent:i}}}var ot={};function Bt(s){return s==="local"?localStorage:sessionStorage}function kn(s,n,i){const u=(i==null?void 0:i.serializer)??JSON,m=(i==null?void 0:i.storage)??"local",d=typeof window<"u"&&typeof document<"u";function v(g,O){d&&Bt(m).setItem(g,u.stringify(O))}if(!ot[s]){const g=W(n,I=>{const $=d?Bt(m).getItem(s):null;if($&&I(u.parse($)),d){const T=z=>{z.key===s&&I(z.newValue?u.parse(z.newValue):null)};return window.addEventListener("storage",T),()=>window.removeEventListener("storage",T)}}),{subscribe:O,set:H}=g;ot[s]={set(I){v(s,I),H(I)},update(I){const $=I(en(g));v(s,$),H($)},subscribe:O}}return ot[s]}kn("introDismissed",!1);const In=W(new Bn),kt=W({responses:{}}),Pt=W([]),Ut=W({}),Ht=W({});export{kt as a,Pt as b,In as n,Ut as p,Ht as r};
